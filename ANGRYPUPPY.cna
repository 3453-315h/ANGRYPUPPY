# ANGRYPUPPY.cna
# Automate BloodHound attack path in Cobalt Strike
#
# Authors: Calvin Hedler (@001SPARTaN) and Vincent Yiu (@vysecurity)
#
# TODO: How the hell do we specify relative paths for import and openf?
# TODO: Parse graph edges
# TODO: Figure out best way to store nodes - I have in hashes right now but ?
# TODO: How to capture relationships - http://sleep.dashnine.org/manual/datastruct.html#3 ?

# org.json from https://mvnrepository.com/artifact/org.json/json
# Documentation - https://stleary.github.io/JSON-java/

import org.json.* from: /Users/vysec/Desktop/Tools/ANGRYPUPPY/json.jar;

# Parse BloodHound graph.json and add nodes

global('%computers %users %groups');

sub parseNodes {
    local('$graph $json');
    $graph = $1;

    $file = openf($graph);

    while $line (readln($file)) {
        $json = $json . $line;
    }

    closef($file);

    # Create new JSONObject from string
    $obj = [new JSONObject: $json];

    # Create a new JSONArray from the "nodes" key
    $nodesArray = [new JSONArray: [$obj get: "nodes"]];

    # How many nodes?
    $length = [$nodesArray length];

    println("Number of nodes: $length");

    # Iterate through all nodes and add to appropriate array
    for ($i = 0; $i < $length; $i++) {
        # Hash to store individual node information
        %node = %();

        $type = [[$nodesArray get: $i] get: "type"];
        $label = [[$nodesArray get: $i] get: "label"];

        %node["label"] = $label;
        %node["type"] = $type;

        if (%node["type"] eq "User") {
            println("Adding user: $label");
            %users[$label] = %node;
        }
        else if (%node["type"] eq "Computer") {
            println("Adding computer: $label");
            %computers[$label] = %node;
        }
        else if (%node["type"] eq "Group") {
            println("Adding group: $label");
            %groups[$label] = %node;
        }
    }

    println("Computers: " . %computers);
    println("Users: " . %users);
    println("Groups: " . %groups);

}

sub generateCypher {
	# check in every beacon
	@items = @();
	foreach $session (beacons()){
		if ("*" isin $session["user"]){
			$user = substr($session["user"], 0, -2);
		}

		if (($user !isin @items)){
			if ($session["user"] ne "SYSTEM"){
				# if user is not in items
				push(@items, $user);
			}
		}
		if (($session["computer"] !isin @items)){
			# if computer is not items
			$computer = $session["computer"];
			if ("*" isin $session["user"]){
				push(@items, $computer);
			}
		}
	}

	
	# QUERY for all nodes we have currently

	$query = "MATCH (n) WHERE (";
	foreach $a (@items){
			$query = $query . "n.name =~ \"(?i)" . $a . "@.*\") OR ("; 	
	}
	$query = $query . ") RETURN n";

	elog("\cB[*] Show all beacon nodes");
	elog("\c9" . $query);

	# QUERY for ALL paths from Current sessions

	# WITH ['CONTEXJ','CONTEXP'] as samAccountNames
	# UNWIND samAccountNames as userNames
	# MATCH (n:User)
	# WHERE n.name STARTS WITH userNames
	# WITH n
	# MATCH (g1:Group)
	# WHERE g1.name STARTS WITH "DOMAIN ADMINS@"
	# MATCH p = allShortestPaths((n)-[r:MemberOf|AdminTo|HasSession*1..]->(g1))
	# RETURN p

	$query = "WITH [";
	foreach $a (@items){
		$query = $query . "'" . $a . "',"; 
	}
	$query = substr($query, 0, -1);

	$query = $query . "] as samAccountNames UNWIND samAccountNames as userNames MATCH (n) WHERE n.name STARTS WITH userNames WITH n MATCH (g1:Group) WHERE g1.name STARTS WITH \"DOMAIN ADMINS@\" MATCH p = allShortestPaths((n)-[r:MemberOf|AdminTo|HasSession*1..]->(g1)) RETURN p";

	elog("\cB[*] Query all beacon nodes to Domain Admins");
	elog("\c9" . $query);

	# QUERY FOR SHORTEST PATH for ANGRYPUPPY

	# WITH ['CONTEXJ','CONTEXP' ] as samAccountNames
	# UNWIND samAccountNames as userNames
	# MATCH (n:User)
	# WHERE n.name STARTS WITH userNames
	# WITH n
	# MATCH (g1:Group)
	# WHERE g1.name STARTS WITH "DOMAIN ADMINS@"
	# MATCH p = allShortestPaths((n)-[r:MemberOf|AdminTo|HasSession*1..]->(g1))
	# RETURN p
	# ORDER BY LENGTH(p) ASC
	# LIMIT 1

	$query = "WITH [";
	foreach $a (@items){
		$query = $query . "'" . $a . "',"; 
	}
	$query = substr($query, 0, -1);

	$query = $query . "] as samAccountNames UNWIND samAccountNames as userNames MATCH (n) WHERE n.name STARTS WITH userNames WITH n MATCH (g1:Group) WHERE g1.name STARTS WITH \"DOMAIN ADMINS@\" MATCH p = allShortestPaths((n)-[r:MemberOf|AdminTo|HasSession*1..]->(g1)) RETURN p ORDER BY LENGTH(p) ASC LIMIT 1";

	elog("\cB[*] Query all beacon nodes to generate ANGRYPUPPY path");
	elog("\c9" . $query);
	
}

sub init {
	# Initialise	
	generateCypher()
}

init()

#parseNodes(getFileProper(script_resource("graphs"), "graph.json"));
