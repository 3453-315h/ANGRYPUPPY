# ANGRYPUPPY.cna
# Automate BloodHound attack path in Cobalt Strike
#
# Authors: Calvin Hedler (@001SPARTaN) and Vincent Yiu (@vysecurity) :)
#
# TODO: How to capture relationships - http://sleep.dashnine.org/manual/datastruct.html#3 ?

# org.json from https://mvnrepository.com/artifact/org.json/json
# Documentation - https://stleary.github.io/JSON-java/
import org.json.* from: /Users/chedler/tools/ANGRYPUPPY/json.jar;

# Parse BloodHound graph.json and add nodes

# Ordered array with attack path in format
# @(@(%node, relationship), @(%node, relationship), @(%lastnode))
global('@relationships @edges @nodes');

alias cypher{
	generateCypher();
}

beacon_command_register("cypher", "Obtains a set of cypher queries for visualisations from current active beacons",
	"Synopsis: cypher\n\n" .
	"Obtains a set of cypher queries for visualisations from current active beacons\nOutputs to event log");

sub parseNodes {
    local('$json');

    $json = $1;

    # Create new JSONObject from string
    $obj = [new JSONObject: $json];

    # Create a new JSONArray from the "nodes" key
    $nodeArray = [new JSONArray: [$obj get: "nodes"]];

    # How many nodes?
    $length = [$nodeArray length];
    println("Number of nodes: $length");

    # Iterate through all nodes and add to appropriate array
    for ($i = 0; $i < $length; $i++) {
        # Hash to store individual node information
        %node = %();

        $id = [[$nodeArray get: $i] get: "id"];
        $type = [[$nodeArray get: $i] get: "type"];
        $label = [[$nodeArray get: $i] get: "label"];

        %node["id"] = $id;
        %node["label"] = $label;
        %node["type"] = $type;

        add(@nodes, %node, -1);
    }

    foreach %node (@nodes) {
        if (%node["type"] eq "Computer") {
            println("Computer: " . %node["label"]);
        }
        else if (%node["type"] eq "User") {
            println("User: " . %node["label"]);
        }
    }
}

sub parseEdges {
    local('$json');
    $json = $1;

    $obj = [new JSONObject: $json];

    $edgeArray = [new JSONArray: [$obj get: "edges"]];

    $length = [$edgeArray length];
    println("Number of edges: $length");

    for ($i = 0; $i < $length; $i++) {
        %edge = %();

        $id = [[$edgeArray get: $i] get: "id"];
        $label = [[$edgeArray get: $i] get: "label"];
        $source = [[$edgeArray get: $i] get: "source"];
        $target = [[$edgeArray get: $i] get: "target"];


        %edge["id"] = $id;
        %edge["label"] = $label;
        %edge["source"] = $source;
        %edge["target"] = $target;

        @edges[$i] = %edge;
        println("Added edge: " . %edge);
    }
}

sub getFirstNode {
    local('@targets');

    foreach %edge (@edges) {
        add(@targets, %edge["target"]);
    }
    foreach %edge (@edges) {
        if (%edge["source"] !isin @targets) {
            foreach %node (@nodes) {
                if (%edge["source"] eq %node["id"]) {
                    return %node;
                }
            }
        }
    }
}

sub getNextNode {
    local('%node');
    %node = $1;

    foreach %edge (@edges) {
    }
}

sub sortNodes {
    local ('@sorted %firstNode');

    %firstNode = getFirstNode();

    add(@sorted, %firstNode, 0);

    foreach %node (@nodes) {
        foreach %edge (@edges) {
        }
    }
}

sub parseGraph {
    local('$graph $json $file');
    $graph = $1;
    $file = openf($graph);

    while $line (readln($file)) {
        $json = $json . $line;
    }

    closef($file);

    parseNodes($json);
    parseEdges($json);

    println("First node is: " . getFirstNode());
}

sub generateCypher {
	# check in every beacon
	@items = @();
	foreach $session (beacons()){

		$user = $session["user"];
		$computer = $session["computer"];

		if ("*" isin $user){
			$user = substr($user, 0, -2);
		}
		

		if ((uc($user) !isin @items)){
			if ($user ne "SYSTEM"){
				# if user is not in items

				push(@items, uc($user));
			}
		}
		if ((uc($computer) !isin @items)){
			# if computer is not items
			if ("*" isin $session["user"]){
				push(@items, uc($computer));
			}
		}
	}

	
	# QUERY for all nodes we have currently

	$query = "MATCH (n) WHERE (";
	foreach $a (@items){
			$query = $query . "n.name =~ \"" . $a . "@.*\") OR ("; 	
	}
	$query = $query . ") RETURN n";

	elog("\cB[*] Show all beacon nodes");
	elog("\c9" . $query);

	# QUERY for ALL paths from Current sessions

	# WITH ['GBARNES','RL-DESKTOP18'] as samAccountNames
	# UNWIND samAccountNames as userNames
	# MATCH (n:User)
	# WHERE n.name STARTS WITH userNames
	# WITH n
	# MATCH (g1:Group)
	# WHERE g1.name STARTS WITH "DOMAIN ADMINS@"
	# MATCH p = allShortestPaths((n)-[r:MemberOf|AdminTo|HasSession*1..]->(g1))
	# RETURN p

	$query = "WITH [";
	foreach $a (@items){
		$query = $query . "'" . $a . "',"; 
	}
	$query = substr($query, 0, -1);

	$query = $query . "] as samAccountNames UNWIND samAccountNames as userNames MATCH (n) WHERE n.name STARTS WITH userNames WITH n MATCH (g1:Group) WHERE g1.name STARTS WITH \"DOMAIN ADMINS@\" MATCH p = allShortestPaths((n)-[r:MemberOf|AdminTo|HasSession*1..]->(g1)) RETURN p";

	elog("\cB[*] Query all beacon nodes to Domain Admins");
	elog("\c9" . $query);

	# QUERY FOR SHORTEST PATH for ANGRYPUPPY

	# WITH ['GBARNES','RL-DESKTOP18'] as samAccountNames
	# UNWIND samAccountNames as userNames
	# MATCH (n:User)
	# WHERE n.name STARTS WITH userNames
	# WITH n
	# MATCH (g1:Group)
	# WHERE g1.name STARTS WITH "DOMAIN ADMINS@"
	# MATCH p = allShortestPaths((n)-[r:MemberOf|AdminTo|HasSession*1..]->(g1))
	# RETURN p
	# ORDER BY LENGTH(p) ASC
	# LIMIT 1

	$query = "WITH [";
	foreach $a (@items){
		$query = $query . "'" . $a . "',"; 
	}
	$query = substr($query, 0, -1);

	$query = $query . "] as samAccountNames UNWIND samAccountNames as userNames MATCH (n) WHERE n.name STARTS WITH userNames WITH n MATCH (g1:Group) WHERE g1.name STARTS WITH \"DOMAIN ADMINS@\" MATCH p = allShortestPaths((n)-[r:MemberOf|AdminTo|HasSession*1..]->(g1)) RETURN p ORDER BY LENGTH(p) ASC LIMIT 1";

	elog("\cB[*] Query all beacon nodes to generate ANGRYPUPPY path");
	elog("\c9" . $query);
	return $query;
}

sub init {
	# Initialise
}

init()

parseGraph("/Users/chedler/tools/ANGRYPUPPY/graph4.json");
