# ANGRYPUPPY.cna
# Automate BloodHound attack path in Cobalt Strike
#
# Authors: Calvin Hedler (@001SPARTaN) and Vincent Yiu (@vysecurity)
#
# TODO: How the hell do we specify relative paths for import and openf?
# TODO: Parse graph edges
# TODO: Figure out best way to store nodes - I have in hashes right now but ?
# TODO: How to capture relationships - http://sleep.dashnine.org/manual/datastruct.html#3 ?

# org.json from https://mvnrepository.com/artifact/org.json/json
# Documentation - https://stleary.github.io/JSON-java/
import org.json.* from: /Users/chedler/tools/ANGRYPUPPY/json.jar;

# Parse BloodHound graph.json and add nodes

# Ordered array with attack path in format
# @(@(%node, relationship), @(%node, relationship), @(%lastnode))
global('@relationships @edges');

sub parseNodes {
    local('$json');

    $json = $1;

    # Create new JSONObject from string
    $obj = [new JSONObject: $json];

    # Create a new JSONArray from the "nodes" key
    $nodeArray = [new JSONArray: [$obj get: "nodes"]];

    # How many nodes?
    $length = [$nodeArray length];
    println("Number of nodes: $length");

    # Iterate through all nodes and add to appropriate array
    for ($i = 0; $i < $length; $i++) {
        # Hash to store individual node information
        %node = %();

        $id = [[$nodeArray get: $i] get: "id"];
        $type = [[$nodeArray get: $i] get: "type"];
        $label = [[$nodeArray get: $i] get: "label"];

        %node["id"] = $id;
        %node["label"] = $label;
        %node["type"] = $type;

        @node = @(%node, "AdminTo");

        add(@relationships, @node, -1);
    }

    foreach @node (@relationships) {
        if (@node[0]["type"] eq "Computer") {
            println("Computer: " . @node[0]["label"]);
        }
        else if (@node[0]["type"] eq "User") {
            println("User: " . @node[0]["label"]);
        }
    }
}

sub parseEdges {
    local('$json');
    $json = $1;

    $obj = [new JSONObject: $json];

    $edgeArray = [new JSONArray: [$obj get: "edges"]];

    $length = [$edgeArray length];
    println("Number of edges: $length");

    for ($i = 0; $i < $length; $i++) {
        %edge = %();

        $id = [[$edgeArray get: $i] get: "id"];
        $label = [[$edgeArray get: $i] get: "label"];
        $source = [[$edgeArray get: $i] get: "source"];
        $target = [[$edgeArray get: $i] get: "target"];


        %edge["id"] = $id;
        %edge["label"] = $label;
        %edge["source"] = $source;
        %edge["target"] = $target;

        @edges[$i] = %edge;
        println("Added edge: " . %edge);
    }
}

sub getFirstNode {
    @targets = @();
    foreach %edge (@edges) {
        add(@targets, %edge["target"]);
    }
    foreach %edge (@edges) {
        if (%edge["source"] !isin @targets) {
            return %edge;
        }
    }
}

sub parseGraph {
    local('$graph $json $file');
    $graph = $1;
    $file = openf($graph);

    while $line (readln($file)) {
        $json = $json . $line;
    }

    closef($file);

    parseNodes($json);
    parseEdges($json);

    println("First node is: " . getFirstNode());
}

parseGraph("/Users/chedler/tools/ANGRYPUPPY/graph3.json");
